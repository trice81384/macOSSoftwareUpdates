#!/bin/bash

## This script is designed to be called from a JAMF policy scoped to run once a day and ideally scoped to a 
## Smart Group where software updates available are greater than 0.
## If updates are found users are notified what the update is and given the opportunity to install them. If reboots
## are required users will also be notified that the machine will be rebooted at the end of the update process.
## Users will then be given the option to reboot their machine or let it reboot automatically after 5 mins.
## Users can also defer the updates for x number of days before they  are automatically installed.
## It is recommended to also enable a self service policy in conjunction with this one  so users can install updates 
## at a more appropriate time for them.

## Many thanks to the many people at www.jamfnation.com for providing the basis and inspiration for this script 
## in particular Mike Morales (@mm270) and his script found here:
## https://github.com/mm2270/CasperSuiteScripts/blob/master/selectable_SoftwareUpdate.sh
## as well as for ideas to run programatic updates on Apple Silicon found here:
## https://babodee.wordpress.com/2021/03/30/handling-major-upgrades-and-minor-updates-for-macos-with-jamf/

## All references to the word "policy" log statements and variables are purely for readability and do not refer to an associated Jamf policy.

# Function to provide logging of the script's actions to the console or the log file specified by the LogFile variable.
ScriptLogging(){

    local LogStamp=$(date +%Y-%m-%d\ %H:%M:%S)
    if [[ -n "$2" ]]
    then
      LogFile="$2"
    else
      LogFile="PATH TO LOG FILE HERE"
    fi
    
    ## To output to the log file append '>> $LogFile' to the below echo statement 
    echo "$LogStamp" " $1"
}

## Define Global Variables and Script Arguments (if not run from Jamf Parameters 1, 2, 3 must be set with ANY value.)
## Since we're using 10+ parameters the variables must be in "${}" format

## Parameter 4 passed in from Jamf will set the total amount of update chances we will give the user.
## If no value is specified it will default to 3.
TotalAttempts="${4}"

## Parameter 5 passed in from Jamf will set the amount of seconds to wait before rebooting the machine to apply the updates. 
## If no value is specified it will default to 300 seconds or 5 mins.
Seconds="${5}"

## Parameter 6 passed in from Jamf will set the day of the week to start the script.
## If no value is specified it will default to any day of the week.
DayofWeek="${6}"

## Parameter 7 passed in from Jamf will set the date to start the script.
## If no valid is specified it will default to the current date. 
## Dates MUST be in the format of YYYY-MM-DD
ActivationDate="${7}"

## Parameter 8 passed in from Jamf will set the time interval to run the script.
## This specifies the frequency to actually check for updates regardless of the 
## execution triggers set in Jamf. For example, only actually check for updates every 30 days even if 
## the script is set to run once a day. This allows the script to run more structured without having to enable/disable 
## its associated policy.
## If no interval is set the script will run every day.
UpdateInterval="${8}"

##### If the script is running and has detected updates Parameters 6, 7, and 8 are ignored until there #####
##### are no more updates available. This makes sure that the user is actually installing the updates.   #####

## Parameter 9 passed in from Jamf will determine if a random delay should be used once the script has been activated.
## This parameter is an integer value representing the max number of days in which a random period of days will be generated.
## If a random number is generated the INITIAL run of the script won't happen until that amount of days has passed.
## This allows a large number of clients not to all run updates on the same day if necessary.
## Changing this number will cause the delay to be enabled again.
DelayPeriod="${9}"

## Parameter 10 passed in from Jamf will set the name of the organization running the script.
## This name is used in various plists, launch daemons, and other configuration options. 
## If no organization name is specified then the default of "My ORG" will be used.
## This name should renmain consistent throughout your jamf environment and in any polices that call this script.
OrgName="${10}"

if [[ -z "$OrgName" ]]
then
OrgName="My ORG"
ScriptLogging "No Organization Name specified. Using \"My ORG\"."
fi

## Remove any white spaces entered with the organizational name and convert it to lower case
FormattedOrgName=$(echo $OrgName | sed 's/ //g' | tr '[:upper:]' '[:lower:]')

## The plist file used for storing script parameters
UpdateAttemptsFile="/Library/Preferences/com.$FormattedOrgName.softwareupdate.plist"

## Clean up the old counter file from previous versions of the script if it is still lying around
if [[ -e "/etc/SUScount.txt" ]]
 then
   rm -f "/etc/SUScount.txt"
fi

## If the file containing the number of software update attempts does not exist or has a size
## of zero bytes then set the number of update attempts to zero by writing just a zero to the file

if [[ ! -s "$UpdateAttemptsFile" ]]
 then
   defaults write $UpdateAttemptsFile UpdateCount -int 0
fi

## Now that we know the update file exists write a value to the JAMFEnabled key
## True indicates updates are being installed via a Jamf policy. Set it to false if there is a need to track the script running locally.

defaults write $UpdateAttemptsFile JAMFEnabled -bool true

## Validate the amount of deferral chances passed in.
## Any value other than a number, including a null value, will result in the the total user chances being set to 3.
## Any number less than 3 will result in the total number of chances being set to 3.

#### All && and || comparisons in the script are broken out into individual constructs simply for readability ####

if [[ "$TotalAttempts" == *[!0-9]* ]] || [[ -z "$TotalAttempts" ]]
then
ScriptLogging "No valid deferral count specified. Defaulting to 3 chances."
TotalAttempts="3"
elif [[ "$TotalAttempts" -lt "3" ]]
then
ScriptLogging "Deferrals set too low. Setting to 3 user attempts."
TotalAttempts="3"
fi

ScriptLogging "Total chances for user to defer is: $TotalAttempts"

## Check the number of seconds passed in for a reboot delay
## Any value other than a number, including a null value, will default the reboot timer to 300 seconds or 5 minutes. 
## reboot timer will default to 300 seconds or 5 minutes. If less that 120 seconds are enter the timer will be set to 2 minutes
## to both give the user enough time to quit any applications and for the 1 minute reboot warning to display.
## We assign the parameter to a variable first just so we don't have to worry about the logic later if we need to.

if [[ "$Seconds" == *[!0-9]* ]] || [[ -z "$Seconds" ]]
then
ScriptLogging "No valid defer time found. Defaulting to 5 mins."
Seconds=300
elif [[ "$Seconds" -le "120" ]]
then
ScriptLogging "Delay timer set to low. Setting to 2 mins."
Seconds=120
fi

### Double parens are required when command substitution is performing arithmetic operations and assignments. ###
### They will be used for most numerical comparisons in the script due to more consistent results. ###
### $ also left on variable names during arthmetic operations for readability purposes ###

## Figure out the amount of whole minutes from inputted seconds.
## This variable will be displayed to the user.
Minutes=$(($Seconds / 60))
ScriptLogging "Machine reboot timer is set to $Minutes minutes."

## Figure out any additional seconds over the total amount of whole minutes
ExtraSeconds=$(($Seconds % 60))

## Subtract the additional seconds from the total amount of seconds which will give us 
## a timer/counter variable in whole minutes.
Counter=$(($Seconds-$ExtraSeconds))

## Get the current date in YYYY-mm-dd format then convert it to epoch time
## This date will be used later to see if the script should be running based on passed in parameters.
CurrentDate=$(date '+%Y-%m-%d')
CurrentDate_Epoch=$(date -jf "%Y-%m-%d" "${CurrentDate}" "+%s")

##Get the full weekday when the script is run as well and convert it to lower case for better pattern matching.
CurrentWeekday=$(date +%A | tr '[:upper:]' '[:lower:]')

## User Variables
## Variable for currently logged in user
loggedInUser=""
SecureTokenEnabled=""
BootstrapTokenEscrowed=""

##Update deferral variables
## Final Chance is 1 more than TotalAttempts and represents at which count the update process will be forced.
FinalChance=$(($TotalAttempts+1))
UpdateCount="0"
UpdateAttempts="0"
UpdateChancesLeft="0"

## Write the contents of UpdateAttemptsFile to a variable so it can be manipulated later
## and written back to the UpdateAttemptsFile based upon user input
UpdateCount=$(defaults read $UpdateAttemptsFile UpdateCount)

## Determine if a restart is required by updates. 0 for no and 1 for yes
RestartReq="0"

#Variable to check to see if we should halt or reboot the machine (SoftWareUpdate_OUTPUT)
SWU_OUTPUT=""

##Define Jamf Variables
JAMFHelperPath="/Library/Application Support/JAMF/bin/jamfHelper.app/Contents/MacOS/jamfHelper"
JAMFHelperTitle="$OrgName Software Update"
JAMFHelperHeading="Software Updates Available"
JAMFHelperTextAlignment="left"
JAMFHelperHeaderAlignment="left"

###JAMFHelperDescription not currently used but can be substituted for a generic message as necessary
JAMFHelperDescription="Please save all your work, quit open programs, and make sure your computer is plugged in.

This process will take approximately 5-10 minutes.

Once completed your computer will reboot and begin the update."

## Jamf Binary Check
##
## This if statement is designed to check for the location of the Jamf binary in multiple places 
## due to changes in OS X associated with Jamf's upgrade to version 9.81
## References to the Jamf Binary must be changed to "$jamfBinary"
##
if [[ -e /usr/local/jamf/bin/jamf ]]
   then
      # Jamf Binary found at 9.81 or later location
      ScriptLogging "Jamf Binary found at 9.81 or later location"
      jamfBinary="/usr/local/jamf/bin/jamf"
      #
   elif [[ -e /usr/local/bin/jamf ]]
   then
      # Alias to the Jamf Binary found
      ScriptLogging "Alias to the Jamf Binary found"
      jamfBinary="/usr/local/bin/jamf"
      #
   else
   ScriptLogging "Jamf Binary not found."
fi
## End Jamf Check if statement

##  Get OS X Versions
osvers_major=$(/usr/bin/sw_vers -productVersion | awk -F. {'print $1'})
osvers_minor=$(/usr/bin/sw_vers -productVersion | awk -F. {'print $2'})
osvers_dot=$(/usr/bin/sw_vers -productVersion | awk -F. {'print $3'})
osvers_full=$(sw_vers -productVersion | cut -d. -f1,2,3)

## Check to see if macOS reports its version as 16 (for some beta versions) and convert it to 11
if [[ "$osvers_major" == "10" ]] && [[ "$osvers_minor" == "16" ]]
then
  ScriptLogging "Converting macOS 10.16 to macOS 11"
  osvers_major="11"
fi

ScriptLogging "Computer is running macOS $osvers_full"

## Find out if the machine has a bootstrap token escrowed to Jamf.
## Bootstrap tokens only apply for macOS 10.15.4 and above.
## Using AWK in this manner means the if statement can't have brackets
if echo "$osvers_full 10.15.4" | awk '{exit $1>=$2?0:1}'
then
   BootstrapTokenEscrowed=$(profiles status -type bootstraptoken | grep escrowed | awk -F ": " '{print $3}')
   if [[ "$BootstrapTokenEscrowed" != "YES" ]]
   then
      ScriptLogging "Bootstrap Token not escrowed. User might not be able to install updates on versions of macOS past 10.15.4"
    else
      ScriptLogging "Bootstrap Token escrowed."
   fi
else
  ScriptLogging "Bootstrap Token not in use for versions of macOS prior to 10.15.4"
fi

## Check to see if the computer is running on Apple Silicon
arch=$(/usr/bin/arch)

##### BEGIN FUNCTION DEFINITIONS ####

#### Function to check user attributes
gatherUserDetails()
{
## Get the current logged in user
loggedInUser=$(ls -l /dev/console | /usr/bin/awk '{ print $3 }')

ScriptLogging "Current logged in user is: $loggedInUser"

## Find out if the currently logged in user has a Secure Token.
## Secure tokens only apply to users on macOS 10.13 or later.
## Using AWK in this manner means the if statement can't have brackets
ScriptLogging "Checking for a Secure Token..."
if echo "$osvers_full 10.13" | awk '{exit $1>=$2?0:1}'
then
   SecureTokenEnabled=$(dscl . -read /Users/$loggedInUser AuthenticationAuthority | grep -o SecureToken)
   if [[ "$SecureTokenEnabled" != "SecureToken" ]]
   then
      ScriptLogging "Secure Token not enabled. User might not be able to install updates on later version of macOS."
   else
      ScriptLogging "'$loggedInUser' has a Secure Token."
   fi
else
  ScriptLogging "OS is $osvers_full. Secure Token not in use for versions of macOS prior to 10.13"
fi

## Find out if the current user has a branded self service icon if not use a default one for Jamf Helper windows based on the OS Version
if [[ -e "/Users/$loggedInUser/Library/Application Support/com.jamfsoftware.selfservice.mac/Documents/Images/brandingimage.png" ]]
   then
      JAMFHelperIcon="/Users/$loggedInUser/Library/Application Support/com.jamfsoftware.selfservice.mac/Documents/Images/brandingimage.png"
   elif echo "$osvers_full 10.13" | awk '{exit $1>$2?0:1}'
   then
      JAMFHelperIcon="/System/Library/PreferencePanes/SoftwareUpdate.prefPane/Contents/Resources/SoftwareUpdate.icns"
   else
      JAMFHelperIcon="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/FinderIcon.icns"
 fi
}

#### Function to run to see if the script should be run on a specific weekday.
checkDayofWeek(){

   ## Variable renamed in plist. Moving it in case it is in use
   if [[ $(defaults read $UpdateAttemptsFile PolicyStartDate 2>/dev/null) != "" ]]
   then
     defaults rename $UpdateAttemptsFile PolicyStartDate PolicyStartWeekday
   fi

## We translate the day to lowercase then an if statement checks for an actual weekday. 
## If there is a match, we set the script to begin on that day. If there is no match the script can run
## whenever there are updates.
DayofWeek=$(echo "$DayofWeek" | tr '[:upper:]' '[:lower:]')

## Check to see if a weekday already exists in the plist and if there is no value write NONE to the plist.
PolicyStartWeekday=$(defaults read $UpdateAttemptsFile PolicyStartWeekday 2>/dev/null)
if [[ -z "$PolicyStartWeekday" ]]
then 
PolicyStartWeekday="NONE"
defaults write $UpdateAttemptsFile PolicyStartWeekday -string "NONE"
fi

if [[ "$DayofWeek" =~ sunday|monday|tuesday|wednesday|thursday|friday|saturday ]]
then
  ## Valid weekday entered

  ## This accounts for organizations that decided to change the day they want the script to start executing on if it is already running.
  ## If they change the execution day to another day of the week the script will stop running until that day arrives.
  ## If they change the day of execution to the current day of the week the script will still run based on other logic.
  if [[ "$PolicyStartWeekday" != "$DayofWeek" ]] && [[ "$DayofWeek" != "$CurrentWeekday" ]]
  then
    ScriptLogging "New start day of $DayofWeek does not match current start day of $PolicyStartWeekday."
    ScriptLogging "Setting policy enabled to false and resetting the deferral counter."
    defaults write $UpdateAttemptsFile PolicyRunning -bool false 
    defaults write $UpdateAttemptsFile PolicyStartWeekday -string "$DayofWeek"
    defaults write $UpdateAttemptsFile UpdateCount -int 0
    return 255
  elif [[ "$DayofWeek" != "$CurrentWeekday" ]]
  then
    ScriptLogging "Policy runs on $DayofWeek's."
    return 255
  elif [[ "$DayofWeek" == "$CurrentWeekday" ]]
  then
    ScriptLogging "Policy start weekday matches today."
    runUpdates="1"
    defaults write $UpdateAttemptsFile PolicyStartWeekday -string "$DayofWeek"
    return
  fi
elif [[ "$PolicyStartWeekday" == "NONE" ]]
then
ScriptLogging "Policy start weekday is NONE. Defaulting policy to on."
runUpdates="1"
return
else
ScriptLogging "No valid start day of week found. Defaulting policy to on."
runUpdates="1"
defaults write $UpdateAttemptsFile PolicyStartWeekday -string "NONE"
return
fi
}

#### Function to run to see if the script should be run today or at a latter date. 
checkActivationDate()
{
   ## PolicyActivationDate is the activation date already assigned to the script while
   ## ActivationDate is the date to activate the script passed in as an argument.

   ## Check to see if a previous activation date exists and if so convert it to epoch time
   if [[ $(defaults read $UpdateAttemptsFile PolicyActivationDate 2>/dev/null) != "" ]]
   then
     PolicyActivationDate=$(defaults read $UpdateAttemptsFile PolicyActivationDate)
     PolicyActivationDate_epoch=$(date -jf "%Y-%m-%d" "${PolicyActivationDate}" "+%s")
   fi

   if [[ $ActivationDate =~ ^[0-9]{4}-((0[1-9])|(1[0-2]))-(0[1-9]|[1-2][0-9]|3[0-1])$ ]]
   ## Use this regex instead if we want to limit the year to between 2020 and 2029
   #^20[0-2][0-9]-((0[1-9])|(1[0-2]))-(0[1-9]|[1-2][0-9]|3[0-1])$
   then
     # Valid Activation Date entered.
     # Convert the Activation Date to epoch time
     ActivationDate_epoch=$(date -jf "%Y-%m-%d" "${ActivationDate}" "+%s")

     ## This accounts for organizations that decided to change the date they want the script to start executing on if it is already running.
     ## If they change the activation date to another date in the future the script will stop running until that date arrives.
     ## We don't need to check if the current PolicyActivationDate is greater than the passed in ActivationDate since the latter is the only one that matters.
     ## We don't use the != conditional otherwise if the PolicyActivationDate was in the future we would get a false positive.
     ## The LastRunDate key is also not reset because we don't necessarily want users to update outside of the set interval.
     if (( "$ActivationDate_epoch" <= "$CurrentDate_Epoch" ))
     then
       ScriptLogging "The policy activation date is set to $ActivationDate which is today or prior."
       defaults write $UpdateAttemptsFile PolicyActivationDate -string "$ActivationDate"
       return
     elif [[ "$PolicyActivationDate_epoch" < "$ActivationDate_epoch" ]] && [[ ! -z "$PolicyActivationDate_epoch" ]]
     then
       ScriptLogging "This policy activation date has been updated to $ActivationDate."
       ScriptLogging "This is later than then current activation date of $PolicyActivationDate"
       ScriptLogging "Changing policy Activation date to the new date."
       ScriptLogging "Setting policy enabled to false and resetting the deferral counter."
       defaults write $UpdateAttemptsFile PolicyRunning -bool false 
       defaults write $UpdateAttemptsFile PolicyActivationDate -string "$ActivationDate"
       defaults write $UpdateAttemptsFile UpdateCount -int 0
       return 255
      else 
      ScriptLogging "The policy activation date is set to $ActivationDate. Exiting."
      return 255
     fi
   ## This condition also prevents the current date being written as the current activation date and chaning the policy status.
   elif [[ "$PolicyActivationDate" != "" ]]
   then
   ScriptLogging "No valid activation date found but the script has already run once. Leaving policy status unchanged."
   else
   ScriptLogging "No valid activation date found. Defaulting policy to always on."
   defaults write $UpdateAttemptsFile PolicyRunning -bool true
   # To prevent time processing errors, we set a null date to date of script execution which will cause the script to remain activated.
   defaults write $UpdateAttemptsFile PolicyActivationDate -string "$CurrentDate"
   fi
}

#### Function to run to see if the computer is ready to check for updates based on the set update frequency.
checkActivationFrequency()
{
  ## Check the number of days passed in as an execution interval for non numeric characters or an empty variable. 
  ## If either of those conditions are true then the script will just continuously run.
  if [[ "$UpdateInterval" == *[!0-9]* ]] || [[ -z "$UpdateInterval" ]]
  then
    ScriptLogging "No valid update interval found. Defaulting policy to always on."
    #Setting the interval to 0 produces more consistent results in this function as opposed to PolicyRunning -bool true
    defaults write $UpdateAttemptsFile PolicyInterval -int 0
  else
    if [[ -z $(defaults read $UpdateAttemptsFile PolicyInterval 2>/dev/null) ]]
    then
      defaults write $UpdateAttemptsFile PolicyInterval -int $UpdateInterval
    elif [[ $(defaults read $UpdateAttemptsFile PolicyInterval 2>/dev/null) != "$UpdateInterval" ]]
    then
     ## This accounts for organizations that decided to change the interval they want the script to start executing at if it is already running.
     ## If they change the interval to another time period the script will stop running until that interval has elapsed.
     ## If the new interval is shorter that the current one the script will be set to deactivated initially which is intended but subsequent 
     ## conditional statements will activate the policy as appropriate.

     ## We don't generate a return code here since we need to see how the new interval is impacted by the last run date of the script
     ## which will be determined below. However, since we reset the interval, we will reset the update count.
      PolicyInterval=$(defaults read $UpdateAttemptsFile PolicyInterval 2>/dev/null)
      ScriptLogging "Policy interval has changed from $PolicyInterval days to $UpdateInterval days."
      ScriptLogging "Stopping policy until new interval is reached."
      ScriptLogging "Setting policy enabled to false and resetting the deferral counter."
      defaults write $UpdateAttemptsFile PolicyInterval -int $UpdateInterval
      defaults write $UpdateAttemptsFile PolicyRunning -bool false 
      defaults write $UpdateAttemptsFile UpdateCount -int 0
    else
    UpdateInterval=$(defaults read $UpdateAttemptsFile PolicyInterval)
    fi

    ## Check to see if the when the script was last run.
    ## We redirect stderr to /dev/null because if the script has never run the LastRunDate key won't exist which 
    ## will cause defaults to throw an error.
    ## If this field does not exist the script will be assumed to have never run so we'll set the last run date to today so it will at least run once.
    ## This is OK since a valid date will get set at the end of successful update cycle.
    if [[ -z $(defaults read $UpdateAttemptsFile LastRunDate 2>/dev/null) ]]
    then
      defaults write $UpdateAttemptsFile LastRunDate "$CurrentDate"
    else
    LastRunDate=$(defaults read $UpdateAttemptsFile LastRunDate 2>/dev/null)
    LastRunDate_epoch=$(date -jf "%Y-%m-%d" "${LastRunDate}" "+%s")
    fi
    ## Calculate the days difference between the current epoch time and the epoch time of the interval date
    ## Done by subtracting the epoch date of the scripts last run time from the current epoch and dividing by the total number of seconds in a day
    days_diff=$(( (CurrentDate_Epoch - LastRunDate_epoch) / (24*3600) ))

    ## Subtracting the difference in days from when the script last ran from the UpdateInterval gives us the days left until the script runs again.
    DaysRemaining=$((UpdateInterval - days_diff))
  
    ## If the difference (in days) of the last successful script execution is greater than the predetermined update interval time
    ## run the script. If not exit the script.
    if (( "$UpdateInterval" == 0 ))
    then 
      ScriptLogging "Update interval set to 0. Running the policy."
      return
    elif (( $days_diff > $UpdateInterval ))
    then
      ScriptLogging "Policy is currently enabled since it's been more than $UpdateInterval days."
      return 
    else
      ScriptLogging "There are $DaysRemaining days left before the policy would automatically run again."
      return 255
   fi
  fi
}

SetRandomDelay()
{
# If the delay interval passed in is not a number or 0 then set it to 0 and update the interval in the plist
# macOS uses POSIX regex so we can't use things like \d to match digits
if [[ "$DelayPeriod" =~ ^[1-9][0-9]*$ ]]
then
ScriptLogging "Random Delay: Delay period of $DelayPeriod entered."
else
ScriptLogging "Random Delay: No valid delay period specified. Defaulting to no delay."
DelayPeriod="0"
defaults write "$UpdateAttemptsFile" DelayPeriod -int "$DelayPeriod"
defaults write "$UpdateAttemptsFile" RandomDelay -int "$DelayPeriod"
fi

# Read the current max delay period set in the plist
CurrentInterval=$(defaults read "$UpdateAttemptsFile" DelayPeriod 2>/dev/null)

## If that current delay period does not match what is in the set in the DelayPeriod value 
## then the delay period has changed so we must recalculate the actual random delay within this time frame.
## A run of the script without a proper delay set will also trigger this condition.
## The generated random delay (in days) is then written to the plist.
## No matter which condition the current delay is assigned to RandomInterval variable.
if [[ "$DelayPeriod" == "0" ]]
then
  ScriptLogging "Random Delay: Interval is set to $DelayPeriod."
elif [[ "$CurrentInterval" != "$DelayPeriod" ]]
#if [[ "$CurrentInterval" != "$DelayPeriod" ]] && [[ "$DelayPeriod" != "0" ]]
then
  ScriptLogging "Random Delay: Interval has changed to $DelayPeriod."
  defaults write "$UpdateAttemptsFile" DelayPeriod -int "$DelayPeriod"
  RandomInterval=$((1 + $RANDOM % $DelayPeriod))
  defaults write "$UpdateAttemptsFile" RandomDelay -int "$RandomInterval"
  
  ScriptLogging "Setting policy enabled to false and resetting the deferral counter."
  defaults write $UpdateAttemptsFile PolicyRunning -bool false 
  defaults write $UpdateAttemptsFile UpdateCount -int 0
else
  ScriptLogging "Random Delay: No change in random delay period."
fi

RandomDelay=$(defaults read "$UpdateAttemptsFile" RandomDelay)

## If RandomDelay has reached 0 run the script.
if [[ "$RandomDelay" == "0" ]]
then
ScriptLogging "Random Delay: Delay has expired. Continue on with the script."
else
ScriptLogging "Random Delay: Waiting $RandomDelay days before updates begin."
## We then calculate the delay left (in days) before the script beings to run. 
## Since the script runs 1x a day we can simply subtract 1 from the set RandomInterval each day.
RandomDelay=$((RandomDelay - 1))
## That updated delay is then written back to the preferences file for future runs of the script.
defaults write "$UpdateAttemptsFile" RandomDelay -int "$RandomDelay"
exit 0
fi
}

#### Function to run if the machine is running on Apple Silicon or Big Sur 11.0
updatesAppleSilicon()
{
ScriptLogging "Start of Apple Silicon Update Function."

if [[ "$loggedInUser" != "root" ]]
then
   UpdateChancesLeft=$((TotalAttempts - UpdateCount))
        if [[ $UpdateChancesLeft = 0 ]]
        then
AppleSiliconFSHeading="Software updates required for your Mac.
Please click the Update button on the bottom right."

AppleSiliconDescription="You are required to install updates at this time.

Clicking update will open the Software Update Preferences Pane.

Once open please install all available updates.

If updates are not installed these prompts will reappear."

          # Invoke a Jamf Helper full screen window and send it to the background. This allows us to then immediately open
          # a Jamf Utility window allowing to user to take whatever action we associate with the buttons.
          # If we don't leave the -description field blank Jamf Helper weirdly uses other variables set for it.
          "$JAMFHelperPath" -windowType fs -icon "$JAMFHelperIcon" -iconSize 128 -heading "$AppleSiliconFSHeading" -description "" &

          ScriptLogging "Aggressive installation of mac OS Updates happening on Apple Silicon."
          UserResponse=$("$JAMFHelperPath" -windowType utility -windowPosition lr -title "$JAMFHelperTitle" \
                          -icon "$JAMFHelperIcon" -iconSize 128 -heading "$JAMFHelperHeading" -description "$AppleSiliconDescription" \
                          -alignDescription "$JAMFHelperTextAlignment" -button1 "Update" -defaultButton 1)
          if [[ $UserResponse == 0 ]] || [[ $UserResponse == 239 ]]
          then
            jamfHelperUID=$(pgrep jamfHelper)
            disown $jamfHelperUID
            open "/System/Library/CoreServices/Software Update.app"
            until SysPrefsPID=$(pgrep "System Preferences")
            do
            sleep 1
            done
            killall jamfHelper
          fi

while [[ "$SysPrefsPID" != "" ]]
do 
SysPrefsPID=$(pgrep "System Preferences")
done

if [[ "$UpdatesReqRestart" != "" ]]
then
#Updates Require Restarts
AppleSiliconUpdatesRestartReq="System Preferences has been closed.

Some of these updates require your machine to reboot.
Click Reboot to do so now or schedule a reboot later.

If these updates have not been installed,
click Reopen to display these prompts again."

## If the user simply closed System Preferences without updating calling getUpdates again will check to see
## if there are updates still pending. If there are no updates left then the updates preference file will get updated 
## accordingly by the function and the script will exit. If there are updates remaining the updatesAppleSilicon function
## (this function) will get called again with no deferrals left and displays messages based on whether or not the updates require a reboot.

       UserResponse=$("$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
               -icon "$JAMFHelperIcon" -iconSize 128 -heading "$JAMFHelperHeading" -alignHeading "$JAMFHelperHeaderAlignment" -description "$AppleSiliconUpdatesRestartReq" \
               -alignDescription "$JAMFHelperTextAlignment" -button1 "Reopen" -button2 "Reboot" -cancelButton 2 )
                ## This first condition accounts for the user selecting cancel or simply closing the window
                if [[ $UserResponse == 2 ]] || [[ $UserResponse == 239 ]]
                then
                  ## Right now there is no good way to know if software updates have been installed here.
                  ## Uncomment the defualts commands to make a good faith decision to reset the counter
                  ## otherwise this reset will be handled by the getUpdates function the next time the script is run.
                  ## Write Zero to the updates attempt file to reset the counter
                  # defaults write $UpdateAttemptsFile UpdateCount -int 0
                  ## Reset the policy enabled status
                  # defaults write $UpdateAttemptsFile PolicyRunning -bool false

                  ScriptLogging "User closed System Preferences with updates needing a reboot."
                  ScriptLogging "System Preferences closed. Prompting user to reboot."
                  rebootComputer
                elif [[ $UserResponse == 0 ]]
                then
                  ScriptLogging "User choose to reopen System Preferences."
                  ScriptLogging "Prompting user to install updates again."
                  getUpdates rerun
                fi

elif [[ "$UpdatesNoRestart" != "" ]]
then
getUpdates
fi
        else
           UpdateAttempts=$((UpdateCount + 1))
           if [[ "$UpdatesReqRestart" != "" ]]
           then
## Keeping these variables right justified helps with Jamf Helper formatting
InformativeTextMsg="The following is waiting to be installed and requires a restart of your computer:

$UpdatesReqRestart

This is user installation attempt $UpdateAttempts of $TotalAttempts.
           
Attempt $FinalChance will repeatedly prompt to install the updates.

Clicking update will open the Software Update Preferences Pane.
Once open please install all available updates.
**Updates may also be run from Self Service.**"

           elif [[ "$UpdatesNoRestart" != "" ]]
           then
InformativeTextMsg="The following is waiting to be installed on your computer:

$UpdatesNoRestart

This is user installation attempt $UpdateAttempts of $TotalAttempts.
           
Attempt $FinalChance will repeatedly prompt to install the updates.

Clicking update will open the Software Update Preferences Pane.
Once open please install all available updates.
**Updates may also be run from Self Service.**"
           fi

           UserResponse=$("$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
               -icon "$JAMFHelperIcon" -iconSize 128 -heading "$JAMFHelperHeading" -alignHeading "$JAMFHelperHeaderAlignment" -description "$InformativeTextMsg" \
               -alignDescription "$JAMFHelperTextAlignment" -button1 "Install" -button2 "Defer" -cancelButton 2 )
                ## This first condition accounts for the user selecting cancel or simply closing the window
                if [[ $UserResponse == 2 ]] || [[ $UserResponse == 239 ]]
                then
                   defaults write $UpdateAttemptsFile UpdateCount -int $UpdateAttempts
                   ScriptLogging "User choose to defer"
                   ScriptLogging "This was user installation attempt $UpdateAttempts of $TotalAttempts."
                   exit 0
                elif [[ $UserResponse == 0 ]]
                then
                  ScriptLogging "User choose to install Software Updates."
                  open "/System/Library/CoreServices/Software Update.app"

                  ## Keep checking to see if Syetem Preferences has no attached PID
                  ## so we know when it's closed which we take to mean updates have been installed.
                  while [[ "$SysPrefsPID" != "" ]]
                  do 
                  SysPrefsPID=$(pgrep "System Preferences")
                  done
                  ScriptLogging "User closed System Preferences."

                  ## Right now there is no good way to know if software updates have been installed here.
                  ## Uncomment the defualts commands to make a good faith decision to reset the counter
                  ## otherwise this reset will be handled by the getUpdates function the next time the script is run.
                  ## Write Zero to the updates attempt file to reset the counter
                  # defaults write $UpdateAttemptsFile UpdateCount -int 0
                  ## Reset the policy enabled status
                  # defaults write $UpdateAttemptsFile PolicyRunning -bool false
                fi
        fi
else
## No user logged in
ScriptLogging "No user logged in. Updates on Apple Silicon require user interaction."
ScriptLogging "Taking no action at this time."
fi
}

##### Function to run if there are no updates that need to be restarted
installUpdatesNoRestart()
{
ScriptLogging "Updates with NO restart function running."
if [[ "$loggedInUser" != "root" ]]
then
   UpdateChancesLeft=$((TotalAttempts - UpdateCount))
        if [[ $UpdateChancesLeft = 0 ]]
        then
           installMSG="Critical software updates are about to run.
Please do not shut down your Mac or put it to sleep.
           
IMPORTANT:
Some applications may quit to install updates.
Please save all work now."
           
           "$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
           -icon "$JAMFHelperIcon" -iconSize 128 -heading "Software Updates Installing" -alignHeading "$JAMFHelperHeaderAlignment" -description "$installMSG" \
           -alignDescription "$JAMFHelperTextAlignment" &
           ScriptLogging "Forced installation of software updates happening."
           sleep 10
           installUpdates
        else
           UpdateAttempts=$((UpdateCount + 1))
           InformativeTextMsg="The following is waiting to be installed on your computer:

$UpdatesNoRestart

This is user installation attempt $UpdateAttempts of $TotalAttempts.
           
Attempt $FinalChance will install updates automatically.

**Updates may also be run from Self Service.**"

           UserResponse=$("$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
               -icon "$JAMFHelperIcon" -iconSize 128 -heading "$JAMFHelperHeading" -alignHeading "$JAMFHelperHeaderAlignment" -description "$InformativeTextMsg" \
               -alignDescription "$JAMFHelperTextAlignment" -button1 "Install" -button2 "Defer" -cancelButton 2 )
                ## This first condition accounts for the user selecting cancel or simply closing the window
                if [[ $UserResponse == 2 ]] || [[ $UserResponse == 239 ]]
                then
                   defaults write $UpdateAttemptsFile UpdateCount -int $UpdateAttempts
                   ScriptLogging "User choose to defer"
                   ScriptLogging "This was user installation attempt $UpdateAttempts of $TotalAttempts."
                   exit 0
                elif [[ $UserResponse == 0 ]]
                then
                  ScriptLogging "User choose to install Software Updates."
                  installUpdates
                fi
         fi
else
installUpdates
fi
}

#### Function to run if there are updates that need to be restarted
updatesWithRestart()
{
ScriptLogging "Updates with restart function running."
if [[ "$loggedInUser" != "root" ]]
then
   UpdateChancesLeft=$((TotalAttempts - UpdateCount))
        if [[ $UpdateChancesLeft = 0 ]]
        then
           installMSG="Critical software updates are about to run.
Please do not shut down your Mac or put it to sleep.
           
IMPORTANT:
We recommend saving any important documents now.
Your Mac will reboot in order to complete the update."
           
           "$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
           -icon "$JAMFHelperIcon" -iconSize 128 -heading "Software Updates Installing" -alignHeading "$JAMFHelperHeaderAlignment" -description "$installMSG" \
           -alignDescription "$JAMFHelperTextAlignment" &
           ScriptLogging "Forced installation of software updates happening."
           sleep 10
           installUpdates    
        else
           UpdateAttempts=$((UpdateCount + 1))
           InformativeTextMsg="The following is waiting to be installed and requires a restart of your computer:

$UpdatesReqRestart

This is user installation attempt $UpdateAttempts of $TotalAttempts.
           
Attempt $FinalChance will install updates automatically and your machine will restart.

**Updates may also be run from Self Service.**"

           UserResponse=$("$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
               -icon "$JAMFHelperIcon" -iconSize 128 -heading "$JAMFHelperHeading" -alignHeading "$JAMFHelperHeaderAlignment" -description "$InformativeTextMsg" \
               -alignDescription "$JAMFHelperTextAlignment" -button1 "Install" -button2 "Defer" -cancelButton 2 )
                ## This first condition accounts for the user selecting cancel or simply closing the window
                if [[ $UserResponse == 2 ]] || [[ $UserResponse == 239 ]]
                then
                   defaults write $UpdateAttemptsFile UpdateCount -int $UpdateAttempts
                   ScriptLogging "User choose to defer"
                   ScriptLogging "This was user installation attempt $UpdateAttempts of $TotalAttempts."
                   exit 0
                elif [[ $UserResponse == 0 ]]
                then
                  ScriptLogging "User choose to install Software Updates."
                  installUpdates
                fi
         fi
else
ScriptLogging "No user logged in. Installing updates."
installUpdates
fi
}

#### Function to install selected updates and display user prompts
installUpdates ()
{
## When invoking this function there should be no Jamf helper windows running
## but just in case there are check for the process, disown it, and kill it.

jamfHelperUID=$(pgrep jamfHelper)

if [[ "$jamfHelperUID" != "" ]]
then
   disown $jamfHelperUID
   killall jamfHelper
fi 

if [[ "$RestartReq" == "1" ]]
then
SoftwareUpdateMessage="Installing Software Updates   
for macOS.

Your computer will reboot when finished.

**Some updates may require your
computer to be shut down instead.**"
else
SoftwareUpdateMessage="Installing Software Updates   
for macOS.

**Some applications may need to be quit
during this process**."
fi

"$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
-icon "$JAMFHelperIcon" -iconSize 128 -heading "Installing Updates" -alignHeading "$JAMFHelperHeaderAlignment" -description "$SoftwareUpdateMessage" \
-alignDescription "$JAMFHelperTextAlignment" &

jamfHelperUID=$(pgrep jamfHelper)
disown $jamfHelperUID

## Call the software update process
## Newer versions of macOS tend to require a different set of update options, particularly --force, to work reliably 
if echo "$osvers_full 10.13.4" | awk '{exit $1<$2?0:1}'
then
    ScriptLogging "Installing software updates according to $osvers_full, looking for halt requirements...."
    SWU_OUTPUT=$(softwareupdate -ia --no-scan | grep -e halt)
  else
    ScriptLogging "Installing software updates according to $osvers_full, force installing...."
    SWU_OUTPUT=$(softwareupdate -ia --no-scan --force --verbose)
fi

## We put the recon here so it runs in the background and as the restart countdown begins.
"$jamfBinary" recon &
## Write Zero to the updates attempt file to reset the counter
defaults write $UpdateAttemptsFile UpdateCount -int 0
## Reset the policy enabled status
defaults write $UpdateAttemptsFile PolicyRunning -bool false

if [[ "$RestartReq" == "1" ]]
then
## Call reboot function
rebootComputer
else
ScriptLogging "Updates do not require restarts."
fi
}

rebootComputer()
{

## Check for the existence of the output file from the Jamf helper command
## left over from previous executions.
if [[ -e /tmp/UserInput ]]
   then
   rm /tmp/UserInput
fi

## Display a Jamf Helper window notifying the user that a reboot in order to update will happen at 
## a specified period of time and give them the option to enable it immediately.
## We send the output to the named pipe and keep the process running in the background which allows for two things.
## It keeps the window displayed but allows the while loop to start the countdown right away and by sending the 
## output of command to the named pipe we can then continually assign its contents to a variable inside the while
## loop allowing the if statement in that loop to check the status of the variable which equates to a user selecting
## to reboot immediately. If we didn't do it this way the output of the command would only get checked once when the 
## command initially ran.

RebootMsg="Your computer will reboot in $Minutes mins
in order to apply the updates.

Please save all work and quit any open applications.

If you would like to defer this reboot
please select an option below."

FinalRebootMessage="   Your computer will reboot in 1 minute.   

Please save all work and quit all applications now.

**Some updates may require your
computer to be shut down instead.**"

ComputerRebootMessage="COMPUTER REBOOT TIME HAS ARRIVED!

**Some updates may require your
computer to be shut down instead.**"

killall jamfHelper

"$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" -icon "$JAMFHelperIcon" \
-iconSize 128 -heading "Software Updates Installed" -alignHeading "$JAMFHelperHeaderAlignment" -description "$RebootMsg" -alignDescription "$JAMFHelperTextAlignment" \
-button1 "Defer Reboot" -button2 "Reboot Now" -showDelayOptions "1800, 3600, 7200, 14400, 28800, 43200" > /tmp/UserInput &

## Assign the counter variable to another variable that we can use in individual counters
Timer=$Counter

## While loop to run for the # of iterations specified by the counter variable (which translates to a whole minute number)
## while checking certain conditions. We inject a 1 second sleep command into each run of the while loop to approximate 5 minutes.
## If we did not have the sleep command the loop would execute too quickly. Once the loop is over the machine will reboot.

while [ "$Timer" != "0" ]
do

## Check contents of named pipe and assign it to UserResponse
UserResponse=$(cat /tmp/UserInput)

### Check to see if user closed the Jamf helper window without selecting a response. If so open it again.
if [[ "$UserResponse" == "239" ]]
  then
   "$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" -icon "$JAMFHelperIcon" \
   -iconSize 128 -heading "Software Updates Installed" -alignHeading "$JAMFHelperHeaderAlignment" -description "$RebootMsg" -alignDescription "$JAMFHelperTextAlignment" \
   -button1 "Defer Reboot" -button2 "Reboot Now" -showDelayOptions "1800, 3600, 7200, 14400, 28800, 43200" > /tmp/UserInput &
    UserResponse=$(cat /tmp/UserInput)
fi

## Since one of the two buttons pressed will return both the number of seconds selected in the counter and the exit code of the button 
## we need to find out which button was pressed in order to take the correct action. This command will strip off the last digit in the code 
## return which tells is which button was pressed. 2 for reboot now and 1 for delay.
## But we also need to capture any delay in seconds do we do that first
UserSelectedDelay=$(cat /tmp/UserInput)
UserResponse=$(echo "${UserResponse: -1}")

## If UserResponse equals 2 (return code of pushing the button) then we assume user has selected to reboot now so
## We set the counter 1 one as a safety measure in case it doesn't break out
## of the loop right away. One more subtraction from the counter variable would occur causing it to equal
## 0 which would also cause the loop to end and the reboot process to start. We could use a break statement here 
## as well but I liked this method.
## If the user response has not equated to 0 then we'll pop up a window displaying that there is only 60
## seconds left before the reboot process is started is started and a reboot happens. We must get the PID of the previous jamfHelper
## process and disown it first (to prevent unnecessary error messages) then kill it before we display the new
## message.

if [[ "$UserResponse" == "2" ]]
  then
     ScriptLogging "User Choose to reboot immediately."
     Timer="1"
elif [[ "$UserResponse" == "1" ]]
  then
     ## Using the {} braces for parameter substitution we can strip off the last character (the button code) with the %? expression
     UserSelectedDelay="${UserSelectedDelay%?}"
     DelayHour=$(date -v+"$UserSelectedDelay"S +"%H")
     DelayMinutes=$(date -v+"$UserSelectedDelay"S +"%M")
     ScriptLogging "User chose to delay reboot until $DelayHour:$DelayMinutes."
     rebootDelay
     exit 0
elif [[ "$Timer" == 60 ]]
  then
     jamfHelperUID=$(pgrep jamfHelper)
     disown $jamfHelperUID
     killall jamfHelper
     "$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
     -icon "$JAMFHelperIcon" -iconSize 128 -heading "Software Updates Installed" -alignHeading "$JAMFHelperHeaderAlignment" -description "$FinalRebootMessage" \
     -alignDescription "$JAMFHelperTextAlignment" &
fi
sleep 1
Timer=$((Timer - 1))
done

## Remove the named pipe
if [[ -e /tmp/UserInput ]]
   then
   rm /tmp/UserInput
fi

jamfHelperUID=$(pgrep jamfHelper)
disown $jamfHelperUID
killall jamfHelper

"$JAMFHelperPath" -windowType utility -title "$JAMFHelperTitle" \
-icon "$JAMFHelperIcon" -iconSize 128 -heading "Software Updates Installed" -alignHeading "$JAMFHelperHeaderAlignment" -description "$ComputerRebootMessage" \
-alignDescription "$JAMFHelperTextAlignment" &

#Pause just so the final message is sure to be seen
sleep 5

## Macs with the T2 chip that have updates with restarts perform better when halted (shutdown) instead of rebooted
## However newer versions of macOS (that can use them) tend to reboot correctly when softwareupdate is called again with the --force and --restart options.
## This also makes sure any updates that were not installed during the initial call to softwareupdate tried again.
## However, Apple silicon macs can just be rebooted normally and should avoid having the softwareupdate binary called to prevent unnecessary prompts.

if echo "$osvers_full 10.13.4" | awk '{exit $1<$2?0:1}' || [[ "$arch" == "arm64" ]]
then
  ScriptLogging "Shutting down/rebooting according to $osvers_full / $arch requirements."
  # Running old software requirements found in macOS before version 10.13.4 or Apple Silicon
  if [[ "$SWU_OUTPUT" != "" ]]
  then
    ScriptLogging "Shutting down the system immediately."
    halt
  else
    ScriptLogging "Restarting the system immediately."
    reboot
  fi
else
  # Running modern software commands found in macOS since 10.13.4 excluding Apple Silicon
  ScriptLogging "Shutting down/rebooting according to $osvers_full / $arch requirements."
  softwareupdate -ia --no-scan --force --restart
fi
}

rebootDelay()
{
## For good measure we'll reset the counters again.
## Write Zero to the updates attempt file to reset the counter
defaults write $UpdateAttemptsFile UpdateCount -int 0
## Reset the policy enabled status
defaults write $UpdateAttemptsFile PolicyRunning -bool false

## Create a reboot marker to let us know if the machine has already been rebooted. We'll create a hidden file in the tmp directory
## so users won't see it but we know it will get cleared out if the machine is rebooted on its own.
RebootMarker="/tmp/.$FormattedOrgName-RebootMarker"

touch $RebootMarker

## We make sure to not quote the here doc delimiter to allow variable expansion and substitution specifically of any variable
## defined previously as we want their values to be passed to the script copied to the client.
## However, there is expansion and substitution of variables that we do not want to happen UNTIL the script is executed on the 
## client. For those variables we precede the $ with a \
## This copies the text literally and those variables will get expanded or populated on the client when the script is executed.
## Simple rule of thumb any variable we collect outside the client script is meant to be expanded and its value transferred to 
## the heredoc while any variable meant to run on the client does not get expanded now and escaped.

cat <<EOF >/Library/Scripts/SoftwareUpdateReboot
#!/bin/bash
#
# This script is called by a LaunchDaemon at a time previously specified and reboots the computer.
# If the computer has already been rebooted then the script and the launch daemon are removed.

## Define Jamf Variables
## We could use the existing variables from earlier but this way the shell doesn't expand them when writing
## out the script so it looks a little cleaner
JAMFHelperPath="/Library/Application Support/JAMF/bin/jamfHelper.app/Contents/MacOS/jamfHelper"
JAMFHelperTitle="$OrgName: Software Update"
JAMFHelperHeading="Software Updates Available"

## OS X Versions
osvers_major=\$(/usr/bin/sw_vers -productVersion | awk -F. {'print \$1'})
osvers_minor=\$(/usr/bin/sw_vers -productVersion | awk -F. {'print \$2'})
osvers_dot=\$(/usr/bin/sw_vers -productVersion | awk -F. {'print \$3'})
osvers_full=\$(sw_vers -productVersion | cut -d. -f1,2,3)

## Hardware Type
arch=\$(/usr/bin/arch)

## Check to see if macOS reports its version as 16 (for some beta versions) and convert it to 11
if [[ "\$osvers_major" == "10" ]] && [[ "\$osvers_minor" == "16" ]]
then
  echo "Converting macOS 10.16 to macOS 11"
  osvers_major="11"
fi

## Check for the existence of the output file from the Jamf helper command left over from previous executions.
if [[ -e /tmp/UserInput ]]
then
  rm /tmp/UserInput
fi

if [[ -e $RebootMarker ]]
then

## Get the current logged in user
loggedInUser=\$(ls -l /dev/console | /usr/bin/awk '{ print \$3 }')

if [[ "\$loggedInUser" != "root" ]]
then

## Find out if the current user has a branded self service icon if not use a default one for Jamf Helper windows. 
if [[ -e "/Users/\$loggedInUser/Library/Application Support/com.jamfsoftware.selfservice.mac/Documents/Images/brandingimage.png" ]]
   then
      JAMFHelperIcon="/Users/\$loggedInUser/Library/Application Support/com.jamfsoftware.selfservice.mac/Documents/Images/brandingimage.png"
   else
      JAMFHelperIcon="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/FinderIcon.icns"
 fi

## Set the initial timer to the amount of seconds passed in as the 5th (defer) parameter in the software update 
## policy and set it to the Counter variable.
## If nothing is passed in or it contains alphanumeric characters set the timer to
## 300 seconds which equals 5 minutes.
## We might need to use let here so it is sure to assign the variable as a number.
## Probably not necessary but just in case.

## Assign the counter variable to another variable that we can use in individual counters
Timer=$Counter

RebootMsg="Deferred reboot time has arrived.

Your computer will reboot in $Minutes minutes
in order to apply updates.

Please save all work and quit any open applications."

FinalRebootMessage="   Your computer will reboot in 1 minute.   

Please save all work and quit all applications now.

**Some updates may require your
computer to be shut down instead.**"

ComputerRebootMessage="COMPUTER REBOOT TIME HAS ARRIVED!

**Some updates may require your
computer to be shut down instead.**"

"\$JAMFHelperPath" -windowType utility -title "\$JAMFHelperTitle" \
-icon "\$JAMFHelperIcon" -iconSize 128 -heading "COMPUTER REBOOT" -alignHeading "$JAMFHelperHeaderAlignment" -description "\$RebootMsg" \
-alignDescription "$JAMFHelperTextAlignment" -button1 "Reboot" > /tmp/UserInput &

while [ "\$Timer" != "0" ]
do
## Check contents of named pipe and assign it to UserResponse

UserResponse=\$(cat /tmp/UserInput)

if [[ "\$UserResponse" == "0" ]]
  then
     echo "Delayed Reboot Executing: User Choose to reboot."
     Timer="1"
  elif [[ "\$Timer" == 60 ]]
  then
     echo "Delayed Reboot Executing: 1 minute on timer left."
     jamfHelperUID=\$(pgrep jamfHelper)
     disown \$jamfHelperUID
     killall jamfHelper
     "\$JAMFHelperPath" -windowType utility -title "\$JAMFHelperTitle" -icon "\$JAMFHelperIcon" -iconSize 128 \
     -heading "COMPUTER REBOOT" -alignHeading "$JAMFHelperHeaderAlignment" -description "\$FinalRebootMessage" -alignDescription "$JAMFHelperTextAlignment" &
fi
sleep 1
Timer=\$((Timer - 1))
done

## Remove the named pipe
if [[ -e /tmp/UserInput ]]
   then
   rm /tmp/UserInput
fi

jamfHelperUID=\$(pgrep jamfHelper)
disown \$jamfHelperUID
killall jamfHelper

"\$JAMFHelperPath" -windowType utility -title "\$JAMFHelperTitle" \
-icon "\$JAMFHelperIcon" -iconSize 128 -heading "Software Updates Installed" -alignHeading "$JAMFHelperHeaderAlignment" -description "\$ComputerRebootMessage" \
-alignDescription "$JAMFHelperTextAlignment" &

#Pause just so the final message is sure to be seen
sleep 5

#end logged in user check
fi

rm /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist
rm /Library/Scripts/SoftwareUpdateReboot
 
## Macs with the T2 chip that have updates with restarts perform better when halted (shutdown) instead of rebooted
## However newer versions of macOS (that can use them) tend to reboot correctly when softwareupdate is called again with the --force and --restart options.
## This also makes sure any updates that were not installed during the initial call to softwareupdate tried again.
## However, Apple silicon macs can just be rebooted normally and should avoid having the softwareupdate binary called to prevent unnecessary prompts.

  if echo "\$osvers_full 10.13.4" | awk '{exit \$1<\$2?0:1}' || [[ "\$arch" == "arm64" ]]
  then
    echo "Shutting down/rebooting according to \$osvers_full / \$arch requirements."
    # Running old software requirements found in macOS before version 10.13.4 or Apple Silicon
    SWU_OUTPUT=\$(softwareupdate -ia --no-scan | grep -e halt)
    if [[ "\$SWU_OUTPUT" != "" ]]
    then
      echo "Shutting down the system immediately."
      halt
    else
      echo "Restarting the system immediately."
      reboot
    fi
  else
    # Running modern software commands found in macOS since 10.13.4 excluding Apple Silicon
    echo "Shutting down/rebooting according to \$osvers_full / \$arch requirements."
    softwareupdate -ia --no-scan --force --restart
  fi

#end marker check
fi

## Remove the script and the Launch Daemon
echo "Reboot marker not found assuming machine has already been rebooted. Removing Launch Dameon if it exists."

if [[ -e /Library/Scripts/SoftwareUpdateReboot ]]
then
rm -f /Library/Scripts/SoftwareUpdateReboot
fi

## Remove and stop the Launch Daemon if it exists
if [[ -e /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist ]]
then
# Remove the Launch Daemon plist file and then unload the actual Daemon from Launch Control
rm -f /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist
launchctl remove com.$FormattedOrgName.SoftwareUpdateReboot
fi
EOF

chown root:wheel /Library/Scripts/SoftwareUpdateReboot
chmod 755 /Library/Scripts/SoftwareUpdateReboot

####Write launch daemon to run local script
cat <<EOF >/Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>Label</key>
<string>com.$FormattedOrgName.SoftwareUpdateReboot</string>
<key>Program</key>
<string>/Library/Scripts/SoftwareUpdateReboot</string>
<key>StartCalendarInterval</key>
<dict>
    <key>Hour</key>
    <integer>$DelayHour</integer>
    <key>Minute</key>
    <integer>$DelayMinutes</integer>
</dict>
</dict>
</plist>
EOF

chown root:wheel /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist
chmod 644 /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist

## The daemon should not be running here but just in case unload it
launchctl unload /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist 2>/dev/null
## Load the daemon
launchctl load /Library/LaunchDaemons/com.$FormattedOrgName.SoftwareUpdateReboot.plist
}

getUpdates()
{
## Remove the file that might contain older updates
if [[ -e /tmp/softwareupdates.txt ]]
then
rm /tmp/softwareupdates.txt
fi

## There are some occasions where we want the software update function to rerun but don't actually need it to
## pull the list from Apple again. In those instances we pass this function "rerun" as argument $1
if [[ "$1" == "rerun" ]]
then
/usr/sbin/softwareupdate --list --no-scan >> /tmp/softwareupdates.txt
else
/usr/sbin/softwareupdate --list >> /tmp/softwareupdates.txt
fi

## Assign updates with or without restarts to the appropriate variables.
UpdatesReqRestart=$(cat /tmp/softwareupdates.txt | egrep 'restart|shutdown' | awk -F ',|\\\(' '{ gsub(/Title:/,""); print$1 }')

UpdatesNoRestart=$(cat /tmp/softwareupdates.txt | egrep -v 'restart|shutdown' | egrep 'recommended|Recommended' | awk -F ',|\\\(' '{ gsub(/Title:/,""); print$1 }')

## Write Date Script Last Run
defaults write $UpdateAttemptsFile LastRunDate -string "$CurrentDate"

if [[ -z "$UpdatesReqRestart" ]] && [[ -z "$UpdatesNoRestart" ]]
then
  ## If there are no macOS updates found reset the counter otherwise run appropriate software update functions.
  if [[ -e "$UpdateAttemptsFile" ]]
  then
    defaults write $UpdateAttemptsFile UpdateCount -int 0
    defaults write $UpdateAttemptsFile PolicyRunning -bool false
    ScriptLogging "No updates found. Resetting the macOS update counter and policy enablement."
  else  
    ScriptLogging "No new software to install. "  
  fi
elif [[ "$arch" == "arm64" ]] 
then
  ScriptLogging "Apple Silicon detected. Invoking different update function."
  defaults write $UpdateAttemptsFile PolicyRunning -bool true
  updatesAppleSilicon
elif [[ "$osvers_major" -ge "12" ]] || [[ "$osvers_major" -eq "11" && "$osvers_minor" -lt "1" ]]
then
  ScriptLogging "macOS Monterey or Big Sur 11.0.x detected. Invoking different update function."
  defaults write $UpdateAttemptsFile PolicyRunning -bool true
  updatesAppleSilicon
elif [[ "$UpdatesReqRestart" != "" ]]
then
  RestartReq=1
  ScriptLogging "Updates with restarts required equals $RestartReq (True)"
  defaults write $UpdateAttemptsFile PolicyRunning -bool true
  updatesWithRestart
elif [[ "$UpdatesNoRestart" != "" ]]
then
  RestartReq=0
  ScriptLogging "Updates with restarts required equals $RestartReq (False)"
  defaults write $UpdateAttemptsFile PolicyRunning -bool true
  installUpdatesNoRestart
fi
}

##############
#### MAIN ####
##############

## Write out the start date of the script.
ScriptLogging "Today is $(date "+%A %Y-%m-%d")"

## These functions MUST come before the check for Policy Status. Functions also must be called in this order.
## Run the checkDayofWeek first allows us to see if the set activation day changed and stop the script if
## it has. This function also sets the runUpdates variable which in turn activates the entire script.
## We then run the date functions checkActivationDate and checkActivationFrequency which each each produce return codes.
## If they both evaluate to true we leave the status of the runUpdates variable unchanged.
## If one evaluates to false (because of a date change) the runUpdates variable gets unset.
## This method proved most consistent for all the different date change scenarios and easiest to monitor reliably. 
## Just using return codes for each function was producing unintended results but prob could be fixed in an update.

checkDayofWeek

## Since we're evaluating return codes we don't need [] or () around the conditions.
if checkActivationDate && checkActivationFrequency
then
ScriptLogging "Policy Start checks completed."
SetRandomDelay
else
unset runUpdates
fi

## Check to see if the runUpdates variable set. Or if the script is currently enabled (PolicyStatus).
## That is it has already been run once but the updates have not yet been installed.
## This enables the script to run on days other than the days specified by the previous functions.
## We redirect stderr to /dev/null because if the script has never run the PolicyStatus key won't exist which 
## will cause defaults to throw an error.
PolicyStatus=$(defaults read $UpdateAttemptsFile PolicyRunning 2>/dev/null)

if [[ "$runUpdates" == "1" ]] || [[ "$PolicyStatus" == "1" ]]
then
ScriptLogging "\"runUpdates\" is set to ${runUpdates:-null}. \"PolicyStatus\" is set to $PolicyStatus."
ScriptLogging "The policy is enabled."
## Get information about the currently logged in user and then call the function to get available updates.
gatherUserDetails
getUpdates
else
ScriptLogging "The current policy status is $PolicyStatus. The policy is disabled (not running)."
fi
